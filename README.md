##### <a name="pageup"></a>



# MANUAL_1C

+ [ШАГ 0, ПЕРВИЧНОЕ СОЗДАНИЕ РЕПОЗИТОРИЯ](#Step0);
+ [ШАГ 1, Начало работы КОГДА РЕПОЗИТОРИЙ (проект) СУЩЕСТВУЕТ на этом ПК](#Step1_1);
+ [ШАГ 1, Начало работы КОГДА РЕПОЗИТОРИЙ (проект) ОТСУТСТВУЕТ на этом ПК](#Step1_2);
+ [ШАГ 2, СОЗДАЕМ И ВЫПОЛНЯЕМ задачу](#Step2);


+ [ШАГ 3, ПЕРЕНОСИМ ИЗМЕНЕНИЯ (задачи в ветку копии)](#Step3);
+ [ШАГ 4, ВНЕДРЕНИЕ (ветки копия в ветку master)](#Step4);
+ [СЛИЯНИЕ ВЕТОК](#Step4_1);




_Схема разработки:_
+ Ветка master всегда содержит исключительно актуальную (рабочую) версию!
+ Любые задачи должны выполнятся в копии, по этому для нее создается ветка copy_20220101_01
+ Для каждой задачи должна создаватся ветке (ITTF_01) от ветки (копии)
+ Задача завершается слиянием ветки задачи (ITTF_01)  с веткой копии
+ Перед внедрением необходимо обновить ветку master до актуальной версии
+ Внедрение задачи завершается слиянием ветки копии с веткой master



# ПЕРВИЧНОЕ СОЗДАНИЕ РЕПОЗИТОРИЯ
##### <a name="Step0"></a>	ПЕРВИЧНОЕ СОЗДАНИЕ РЕПОЗИТОРИЯ [(начало)](#pageup);


1. **Создаем репозиторий** "X" на удаленном сервере github

    _**ВАЖНО** при создании репозитория, выбрать: **Add .gitignore**_
    _указав template: **Scheme** (какой шаблон неважно)_

2. Редактируем файл .gitignore: очищаем, добавляем **ConfigDumpInfo.xml**, сохраняем

3. _Открываем консоль и выполняем команды:_
#    
    cd ПутьГдеБудемХранитьКаталог_Х_СПроектом
    git clone httpsRepositoryPath
    cd ИмяКлонированногоРепозитория
    git branch -m master (переименовать ветку на master)

4. Создаем актуальную _РЕЗЕРВНУЮ копию_ и работаем в дальнейшем с ней
5. Открываем (в) конфигуратор (торе) актуальную _РЕЗЕРВНУЮ копию_
6. Выполнил команду   **"Выгрузить конфигурацию в файлы"/"Выгрузить в файлы"**

   _где каталОг для выгружаемых файлов это ЛокальныйКаталог-КлонированыйРепозиторий_

7. Открываем консоль и выполняем команды:
#
    git add .
    git commit -m "init v2.1.0.0"
    git push -u origin master
    
   _// где master - это имя первичной ветки_

   _// Если файл попал в индекс не смотря на **.gitignore** и нужно убрать его из индекса: **git rm --cached path/to/file**_
   
Таким образом мы создаем бессрочный репозиторий с веткой master в которой будет исключительно актуальная (рабочая) версия обк!



# ШАГ 1, Начало работы КОГДА РЕПОЗИТОРИЙ (проект) **СУЩЕСТВУЕТ** на этом ПК
##### <a name="Step1_1"></a>	ШАГ 1,  Начало работы КОГДА РЕПОЗИТОРИЙ (проект) **СУЩЕСТВУЕТ** на этом ПК [(начало)](#pageup);



1. Открываем консоль и выполняем команды:
#
    cd КорневойКаталОг_Х_Проекта
    git pull httpsRepositoryPath



# ШАГ 1, Начало работы КОГДА РЕПОЗИТОРИЙ (проект) **ОТСУТСТВУЕТ** на этом ПК
##### <a name="Step1_2"></a>	ШАГ 1, Начало работы КОГДА РЕПОЗИТОРИЙ (проект) **ОТСУТСТВУЕТ** на этом ПК [(начало)](#pageup);



1. Открываем консоль и выполняем команды:
#
    cd ПутьГдеБудемХранитьКаталог_Х_СПроектом
    git clone httpsRepositoryPath
    cd ИмяКлонированногоРепозитория



# ШАГ 2, СОЗДАЕМ И ВЫПОЛНЯЕМ задачу
##### <a name="Step2"></a>	ШАГ 2, СОЗДАЕМ И ВЫПОЛНЯЕМ задачу [(начало)](#pageup);



0. Убедится что существует ветка копии master и выбрать ее (**git checkout -b** copy_20220101_01)
1. Создаем ветку _(в ветки копии)_ для выполнения "задачи": **git branch** ITTF_01
2. Переходим на ветку задачи:               **git checkout** ITTF_01
3. Проверяем переход:                       **git branch**

4. Открываем конфигурацию    "Х" (или открыл обк "Х") _(РЕЗЕРВНУЮ копию)_

5. Вносим изменения
6. Выполнил команду   **"Выгрузить конфигурацию в файлы"/"Выгрузить в файлы"**
#
    git add .
    git status
    git commit -m "some comment"

∞ **Повторяем с шага №5**


# Выгрузить ветку
1. Когда захотим выгрузить ветку на удаленный сервер:
#    
    git push -u origin ITTF_01



# ШАГ 3, ПЕРЕНОСИМ ИЗМЕНЕНИЯ _(задачи в ветку копии)_
##### <a name="Step3"></a>  ПЕРЕНОСИМ ИЗМЕНЕНИЯ _(задачи в ветку копии)_ [(начало)](#pageup);



1. Переходим на ветку копии: git checkout copy_20220101_01
2. Выполняем слияние ветки копия с веткой задачи: git merge ITTF_01



# ШАГ 4, ВНЕДРЕНИЕ _(ветки копия в ветку master)_
##### <a name="Step4"></a>	ШАГ 4, ВНЕДРЕНИЕ _(ветки копия в ветку master)_ [(начало)](#pageup);

Обновляем ветку master до актуальных данных:

1. Переходим на ветку master: git checkout master
2. Открываем конфигурацию "Х" (или открыл обк "Х") с актуальными данными (РАБОЧАЯ база)
3. Выполнил команду   **"Выгрузить конфигурацию в файлы"/"Выгрузить в файлы"**
    _где каталОг для выгружаемых файлов это ЛокальныйРепозиторийПроекта_
    _(сохраняем с заменой текущих файлов). Командой git status можно увидеть изменения_
#
    git add .
    git commit -m "update_to_current_data"
    git push -u origin master



**СЛИЯНИЕ ВЕТОК** master и copy_xxxxxxxx_xx
##### <a name="Step4_1"></a>	**СЛИЯНИЕ ВЕТОК** master и copy_xxxxxxxx_xx [(начало)](#pageup);

1. Переходим на принимающую ветку:                                      **git checkout master**
2. Что бы получить последние коммиты ветки:                             **git fetch**
3. Затем убедитесь, что в ветке master содержатся последние изменения:  **git pull**
#
    git merge** copy_xxxxxxxx_xx
    git commit -m "merge ITTF_01_ITTF_02"
    git push -u origin master
   _// где "copy_xxxxxxxx_xx" - это название ветки-источник_
   _// где master - это имя первичной ветки._
   
    git fetch
    git pull
4. Открываем рабочую базу (заблокированную нами) и _"Загрузить конфигурацию из файлов/ Загрузить из файлов"_


7. Удаляем вспомогательную ветку созданную для актуализации данных:   **git branch -d** copy_xxxxxxxx_xx [(начало)](#pageup);



# Добплнительно:
    На удаленный сервер выгружаются из локального репозитория ИСКЛЮЧИТЕЛЬНО
    те ветки из которых была выполнена команда push. Что бы выгрузить две
    ветки необходимо в каждой из них выполнить команду push
    (иначе ветка останется исключительно в текущем локальном репозитории)
    
    С какой ветки выполняется команда создать новую ветку - с той ветки
    начинается новое ответвление (копируется именно та ветка С которой выполнена команда!)



[(начало)](#pageup);
